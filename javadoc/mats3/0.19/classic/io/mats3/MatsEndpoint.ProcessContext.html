<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>MatsEndpoint.ProcessContext (mats3 0.19.9-2023-05-04 API)</title>
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="MatsEndpoint.ProcessContext (mats3 0.19.9-2023-05-04 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":6,"i13":6,"i14":6,"i15":18};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],16:["t5","Default Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../io/mats3/MatsEndpoint.MatsRefuseMessageException.html" title="class in io.mats3"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../io/mats3/MatsEndpoint.ProcessContextWrapper.html" title="class in io.mats3"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?io/mats3/MatsEndpoint.ProcessContext.html" target="_top">Frames</a></li>
<li><a href="MatsEndpoint.ProcessContext.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">io.mats3</div>
<h2 title="Interface MatsEndpoint.ProcessContext" class="title">Interface MatsEndpoint.ProcessContext&lt;R&gt;</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Superinterfaces:</dt>
<dd><a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html" title="interface in io.mats3">MatsEndpoint.DetachedProcessContext</a></dd>
</dl>
<dl>
<dt>All Known Implementing Classes:</dt>
<dd><a href="../../io/mats3/impl/jms/JmsMatsProcessContext.html" title="class in io.mats3.impl.jms">JmsMatsProcessContext</a>, <a href="../../io/mats3/MatsEndpoint.ProcessContextWrapper.html" title="class in io.mats3">MatsEndpoint.ProcessContextWrapper</a></dd>
</dl>
<dl>
<dt>Enclosing interface:</dt>
<dd><a href="../../io/mats3/MatsEndpoint.html" title="interface in io.mats3">MatsEndpoint</a>&lt;<a href="../../io/mats3/MatsEndpoint.html" title="type parameter in MatsEndpoint">R</a>,<a href="../../io/mats3/MatsEndpoint.html" title="type parameter in MatsEndpoint">S</a>&gt;</dd>
</dl>
<hr>
<br>
<pre>public static interface <span class="typeNameLabel">MatsEndpoint.ProcessContext&lt;R&gt;</span>
extends <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html" title="interface in io.mats3">MatsEndpoint.DetachedProcessContext</a></pre>
<div class="block">A way for the process stage to communicate with the library, providing methods to invoke a request, send a reply
 (for multi-stage endpoints, this provides a way to do a "early return"), initiate a new message etc.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t5" class="tableTab"><span><a href="javascript:show(16);">Default Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#addBytes-java.lang.String-byte:A-">addBytes</a></span>(java.lang.String&nbsp;key,
        byte[]&nbsp;payload)</code>
<div class="block">Attaches a binary payload ("sideload") to the next outgoing message, being it a request or a reply.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#addString-java.lang.String-java.lang.String-">addString</a></span>(java.lang.String&nbsp;key,
         java.lang.String&nbsp;payload)</code>
<div class="block">Attaches a <code>String</code> payload ("sideload") to the next outgoing message, being it a request or a
 reply.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#doAfterCommit-java.lang.Runnable-">doAfterCommit</a></span>(java.lang.Runnable&nbsp;runnable)</code>
<div class="block">The Runnable will be performed after messaging and external resources (DB) have been committed.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>&lt;T&gt;&nbsp;java.util.Optional&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#getAttribute-java.lang.Class-java.lang.String...-">getAttribute</a></span>(java.lang.Class&lt;T&gt;&nbsp;type,
            java.lang.String...&nbsp;name)</code>
<div class="block">Provides a way to get hold of (optional) attributes/objects from the Mats implementation, either specific to
 the Mats implementation in use, or configured into this instance of the Mats implementation.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code><a href="../../io/mats3/MatsInitiator.MessageReference.html" title="interface in io.mats3">MatsInitiator.MessageReference</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#goTo-java.lang.String-java.lang.Object-">goTo</a></span>(java.lang.String&nbsp;endpointId,
    java.lang.Object&nbsp;gotoDto)</code>
<div class="block">Sends a message which passes the current call stack over to another endpoint, so that when that endpoint
 replies, it will return to the endpoint which invoked this endpoint.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="../../io/mats3/MatsInitiator.MessageReference.html" title="interface in io.mats3">MatsInitiator.MessageReference</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#goTo-java.lang.String-java.lang.Object-java.lang.Object-">goTo</a></span>(java.lang.String&nbsp;endpointId,
    java.lang.Object&nbsp;gotoDto,
    java.lang.Object&nbsp;initialTargetSto)</code>
<div class="block"><b>Variation of <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#goTo-java.lang.String-java.lang.Object-"><code>goTo(String, Object)</code></a> method</b>, where the incoming state is sent along.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#initiate-io.mats3.MatsInitiator.InitiateLambda-">initiate</a></span>(<a href="../../io/mats3/MatsInitiator.InitiateLambda.html" title="interface in io.mats3">MatsInitiator.InitiateLambda</a>&nbsp;lambda)</code>
<div class="block">Initiates a new message out to an endpoint.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#logMeasurement-java.lang.String-java.lang.String-java.lang.String-double-java.lang.String...-">logMeasurement</a></span>(java.lang.String&nbsp;metricId,
              java.lang.String&nbsp;metricDescription,
              java.lang.String&nbsp;baseUnit,
              double&nbsp;measure,
              java.lang.String...&nbsp;labelKeyValue)</code>
<div class="block">Adds a measurement of a described variable, in a base unit, for this Stage - <b>be sure to understand that
 the three String parameters are <i>constants</i> for each measurement.</b> To exemplify, you may measure five
 different things in a Stage, i.e.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#logTimingMeasurement-java.lang.String-java.lang.String-long-java.lang.String...-">logTimingMeasurement</a></span>(java.lang.String&nbsp;metricId,
                    java.lang.String&nbsp;metricDescription,
                    long&nbsp;nanos,
                    java.lang.String...&nbsp;labelKeyValue)</code>
<div class="block">Same as <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#logMeasurement-java.lang.String-java.lang.String-java.lang.String-double-java.lang.String...-"><code>addMeasurement(..)</code></a>, but
 specifically for timings - <b>Read that JavaDoc!</b>
 <p/>
 Note: It is illegal to use the same 'metricId' for more than one measurement for a given stage, and this also
 goes between timing measurements and <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#logMeasurement-java.lang.String-java.lang.String-java.lang.String-double-java.lang.String...-"><code>measurements</code></a>.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="../../io/mats3/MatsInitiator.MessageReference.html" title="interface in io.mats3">MatsInitiator.MessageReference</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#next-java.lang.Object-">next</a></span>(java.lang.Object&nbsp;nextDto)</code>
<div class="block">Sends a message which passes the control to the next stage of a multi-stage endpoint.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#nextDirect-java.lang.Object-">nextDirect</a></span>(java.lang.Object&nbsp;nextDirectDto)</code>
<div class="block">Specialized, less resource demanding, and faster "direct" variant of <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#next-java.lang.Object-"><code>next(Object)</code></a> which executes the
 next stage of a multi-stage endpoint within the same stage processor and transactional demarcation that this
 stage is in - that is, there is no actual message sent.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code><a href="../../io/mats3/MatsInitiator.MessageReference.html" title="interface in io.mats3">MatsInitiator.MessageReference</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#reply-R-">reply</a></span>(<a href="../../io/mats3/MatsEndpoint.ProcessContext.html" title="type parameter in MatsEndpoint.ProcessContext">R</a>&nbsp;replyDto)</code>
<div class="block">Sends a reply to the requesting service.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="../../io/mats3/MatsInitiator.MessageReference.html" title="interface in io.mats3">MatsInitiator.MessageReference</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#request-java.lang.String-java.lang.Object-">request</a></span>(java.lang.String&nbsp;endpointId,
       java.lang.Object&nbsp;requestDto)</code>
<div class="block">Sends a request message, meaning that the specified endpoint will be invoked, with the reply-to endpointId
 set to the next stage in the multi-stage endpoint.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#setTraceProperty-java.lang.String-java.lang.Object-">setTraceProperty</a></span>(java.lang.String&nbsp;propertyName,
                java.lang.Object&nbsp;propertyValue)</code>
<div class="block">Adds a property that will "stick" with the Mats Trace from this call on out.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>byte[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#stash--">stash</a></span>()</code>
<div class="block">Returns a binary representation of the current Mats flow's incoming execution point, which can be
 <code>unstashed</code> again at a later time
 using the <a href="../../io/mats3/MatsInitiator.html" title="interface in io.mats3"><code>MatsInitiator</code></a>, thereby providing a simplistic "continuation" feature in Mats.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>default <a href="../../io/mats3/MatsEndpoint.ProcessContext.html" title="interface in io.mats3">MatsEndpoint.ProcessContext</a>&lt;<a href="../../io/mats3/MatsEndpoint.ProcessContext.html" title="type parameter in MatsEndpoint.ProcessContext">R</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#unwrapFully--">unwrapFully</a></span>()</code>&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.io.mats3.MatsEndpoint.DetachedProcessContext">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;io.mats3.<a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html" title="interface in io.mats3">MatsEndpoint.DetachedProcessContext</a></h3>
<code><a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getBytes-java.lang.String-">getBytes</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getBytesKeys--">getBytesKeys</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getEndpointId--">getEndpointId</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getFromAppName--">getFromAppName</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getFromAppVersion--">getFromAppVersion</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getFromStageId--">getFromStageId</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getFromTimestamp--">getFromTimestamp</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getInitiatingAppName--">getInitiatingAppName</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getInitiatingAppVersion--">getInitiatingAppVersion</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getInitiatingTimestamp--">getInitiatingTimestamp</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getInitiatorId--">getInitiatorId</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getMatsMessageId--">getMatsMessageId</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getStageId--">getStageId</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getString-java.lang.String-">getString</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getStringKeys--">getStringKeys</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getSystemMessageId--">getSystemMessageId</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getTraceId--">getTraceId</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getTraceProperty-java.lang.String-java.lang.Class-">getTraceProperty</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#isInteractive--">isInteractive</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#isNoAudit--">isNoAudit</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#isNonPersistent--">isNonPersistent</a>, <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#toString--">toString</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="addBytes-java.lang.String-byte:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addBytes</h4>
<pre>void&nbsp;addBytes(java.lang.String&nbsp;key,
              byte[]&nbsp;payload)</pre>
<div class="block">Attaches a binary payload ("sideload") to the next outgoing message, being it a request or a reply. Note that
 for initiations, you have the same method on the <a href="../../io/mats3/MatsInitiator.MatsInitiate.html" title="interface in io.mats3"><code>MatsInitiator.MatsInitiate</code></a> instance.
 <p/>
 The rationale for having this is to not have to encode a largish byte array inside the JSON structure that
 carries the Request or Reply DTO - byte arrays represent very badly in JSON.
 <p/>
 Note: The byte array is not compressed (as might happen with the DTO), so if the payload is large, you might
 want to consider compressing it before attaching it (and will then have to decompress it on the receiving
 side).
 <p/>
 Note: This will be added to the subsequent <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#request-java.lang.String-java.lang.Object-"><code>request</code></a>, <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#reply-R-"><code>reply</code></a> or <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#next-java.lang.Object-"><code>next</code></a> message - and then cleared. Thus, if you perform multiple request or
 next calls, then each must have their binaries, strings and trace properties set separately. (Any
 <code>initiations</code> are separate from this, neither getting nor consuming binaries,
 strings nor trace properties set on the <code>ProcessContext</code> - they must be set on the
 <a href="../../io/mats3/MatsInitiator.MatsInitiate.html" title="interface in io.mats3"><code>MatsInitiate</code></a> instance within the initiate-lambda).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>key</code> - the key on which to store the byte array payload. The receiver will have to use this key to get
            the payload out again, so either it will be a specific key that the sender and receiver agree
            upon, or you could generate a random key, and reference this key as a field in the outgoing DTO.</dd>
<dd><code>payload</code> - the payload to store.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getBytes-java.lang.String-"><code>MatsEndpoint.DetachedProcessContext.getBytes(String)</code></a>, 
<a href="../../io/mats3/MatsEndpoint.ProcessContext.html#addString-java.lang.String-java.lang.String-"><code>addString(String, String)</code></a>, 
<a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getString-java.lang.String-"><code>MatsEndpoint.DetachedProcessContext.getString(String)</code></a></dd>
</dl>
</li>
</ul>
<a name="addString-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addString</h4>
<pre>void&nbsp;addString(java.lang.String&nbsp;key,
               java.lang.String&nbsp;payload)</pre>
<div class="block">Attaches a <code>String</code> payload ("sideload") to the next outgoing message, being it a request or a
 reply. Note that for initiations, you have the same method on the <a href="../../io/mats3/MatsInitiator.MatsInitiate.html" title="interface in io.mats3"><code>MatsInitiator.MatsInitiate</code></a> instance.
 <p/>
 The rationale for having this is to not have to encode a largish string document inside the JSON structure
 that carries the Request or Reply DTO.
 <p/>
 Note: The String payload is not compressed (as might happen with the DTO), so if the payload is large, you
 might want to consider compressing it before attaching it and instead use the
 <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#addBytes-java.lang.String-byte:A-"><code>addBytes(..)</code></a> method (and will then have to decompress it on the receiving
 side).
 <p/>
 Note: This will be added to the subsequent <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#request-java.lang.String-java.lang.Object-"><code>request</code></a>, <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#reply-R-"><code>reply</code></a> or <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#next-java.lang.Object-"><code>next</code></a> message - and then cleared. Thus, if you perform multiple request or
 next calls, then each must have their binaries, strings and trace properties set separately. (Any
 <code>initiations</code> are separate from this, neither getting nor consuming binaries,
 strings nor trace properties set on the <code>ProcessContext</code> - they must be set on the
 <a href="../../io/mats3/MatsInitiator.MatsInitiate.html" title="interface in io.mats3"><code>MatsInitiate</code></a> instance within the initiate-lambda).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>key</code> - the key on which to store the String payload. The receiver will have to use this key to get the
            payload out again, so either it will be a specific key that the sender and receiver agree upon, or
            you could generate a random key, and reference this key as a field in the outgoing DTO.</dd>
<dd><code>payload</code> - the payload to store.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getString-java.lang.String-"><code>MatsEndpoint.DetachedProcessContext.getString(String)</code></a>, 
<a href="../../io/mats3/MatsEndpoint.ProcessContext.html#addBytes-java.lang.String-byte:A-"><code>addBytes(String, byte[])</code></a>, 
<a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getBytes-java.lang.String-"><code>MatsEndpoint.DetachedProcessContext.getBytes(String)</code></a></dd>
</dl>
</li>
</ul>
<a name="setTraceProperty-java.lang.String-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setTraceProperty</h4>
<pre>void&nbsp;setTraceProperty(java.lang.String&nbsp;propertyName,
                      java.lang.Object&nbsp;propertyValue)</pre>
<div class="block">Adds a property that will "stick" with the Mats Trace from this call on out. Note that for initiations, you
 have the same method on the <a href="../../io/mats3/MatsInitiator.MatsInitiate.html" title="interface in io.mats3"><code>MatsInitiator.MatsInitiate</code></a> instance. The functionality effectively acts like a
 <code>ThreadLocal</code> when compared to normal java method invocations: If the Initiator adds it, all subsequent
 stages will see it, on any stack level, including the terminator. If a stage in a service nested some levels
 down in the stack adds it, it will be present in all subsequent stages including all the way to the
 Terminator. Note that any initiations within a Stage will also inherit trace properties present on the
 Stage's incoming message.
 <p/>
 Possible use cases: You can for example "sneak along" some property meant for Service X through an invocation
 of intermediate Service A (which subsequently calls Service X), where the signature (DTO) of the intermediate
 Service A does not provide such functionality. Another usage would be to add some "global context variable",
 e.g. "current user", that is available for any down-stream Service that requires it. Both of these scenarios
 can obviously lead to pretty hard-to-understand code if used extensively: When employed, you should code
 rather defensively, where if this property is not present when a stage needs it, it should throw
 <a href="../../io/mats3/MatsEndpoint.MatsRefuseMessageException.html" title="class in io.mats3"><code>MatsEndpoint.MatsRefuseMessageException</code></a> and clearly explain that the property needs to be present.
 <p/>
 Note: This will be added to the subsequent <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#request-java.lang.String-java.lang.Object-"><code>request</code></a>, <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#reply-R-"><code>reply</code></a> or <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#next-java.lang.Object-"><code>next</code></a> message - and then cleared. Thus, if you perform multiple request or
 next calls, then each must have their binaries, strings and trace properties set separately. (Any
 <code>initiations</code> are separate from this, neither getting nor consuming binaries,
 strings nor trace properties set on the <code>ProcessContext</code> - they must be set on the
 <a href="../../io/mats3/MatsInitiator.MatsInitiate.html" title="interface in io.mats3"><code>MatsInitiate</code></a> instance within the initiate-lambda).
 <p/>
 Note: <i>incoming</i> trace properties (that was present on the incoming message) will be added to <i>all</i>
 outgoing message, <i>including initiations within the stage</i>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>propertyName</code> - the name of the property</dd>
<dd><code>propertyValue</code> - the value of the property, which will be serialized using the active MATS serializer.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getTraceProperty-java.lang.String-java.lang.Class-"><code>MatsEndpoint.DetachedProcessContext.getTraceProperty(String, Class)</code></a>, 
<a href="../../io/mats3/MatsEndpoint.ProcessContext.html#addString-java.lang.String-java.lang.String-"><code>addString(String, String)</code></a>, 
<a href="../../io/mats3/MatsEndpoint.ProcessContext.html#addBytes-java.lang.String-byte:A-"><code>addBytes(String, byte[])</code></a></dd>
</dl>
</li>
</ul>
<a name="logMeasurement-java.lang.String-java.lang.String-java.lang.String-double-java.lang.String...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>logMeasurement</h4>
<pre>void&nbsp;logMeasurement(java.lang.String&nbsp;metricId,
                    java.lang.String&nbsp;metricDescription,
                    java.lang.String&nbsp;baseUnit,
                    double&nbsp;measure,
                    java.lang.String...&nbsp;labelKeyValue)</pre>
<div class="block">Adds a measurement of a described variable, in a base unit, for this Stage - <b>be sure to understand that
 the three String parameters are <i>constants</i> for each measurement.</b> To exemplify, you may measure five
 different things in a Stage, i.e. "number of items in order", "total amount for order in dollar", etc - and
 each of these obviously have different metricId, metricDescription and possibly different baseUnit from each
 other. BUT, the specific arguments for "number of items in order" (outside the measure itself!) shall not
 change between one Stage processing and the next: e.g. the metricDescription shall <b>NOT</b> be dynamically
 constructed to e.g. say <i>"Number of items in order 1234 for customer 5678"</i>.
 <p/>
 Note: It is illegal to use the same 'metricId' for more than one measurement for a given stage, and this also
 goes between measurements and <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#logTimingMeasurement-java.lang.String-java.lang.String-long-java.lang.String...-"><code>timing
 measurements</code></a>.
 <p/>
 <b>Inclusion as metric by plugin 'mats-intercept-micrometer'</b>: A new meter will be created (and cached),
 of type <code>DistributionSummary</code>, with the 'name' set to
 <code>"mats.exec.ops.measure.{metricId}.{baseUnit}"</code> ("measure"-&gt;"time" for timings), and
 'description' to description. (Tags/labels already added on the meter by the plugin include 'appName',
 'initiatorId', 'initiatingAppName', 'stageId' (for stages), and 'initiatorName' (for inits)). Read about
 parameter 'labelKeyValue' below.
 <p/>
 <b>Inclusion as log line by plugin 'mats-intercept-logging'</b>: A log line will be output by each added
 measurement, where the MDC for that log line will have an entry with key
 <code>"mats.ops.measure.{metricId}.{baseUnit}"</code>. Read about parameter 'labelKeyValue' below.
 <p/>
 It generally makes most sense if the same metrics are added for each processing of a particular Stage, i.e.
 if the "number of items" are 0, then that should also be recorded along with the "total amount for order in
 dollar" as 0, not just elided. Otherwise, your metrics will be skewed.
 <p/>
 You should use a dot-notation for the metricId if you want to add multiple meters with a
 hierarchical/subdivision layout.
 <p/>
 The vararg 'labelKeyValue' is an optional element where the String-array consist of one or several alternate
 key, value pairs. <b>Do not employ this feature unless you know what the effects are, and you actually need
 it!</b> This will be added as labels/tags to the metric, and added to the SLF4J MDC for the measurement log
 line with the key being <code>"mats.ops.measure.{metricId}.{labelKey}"</code> ("measure"-&gt;"time" for
 timings). The keys should be constants as explained for the other parameters, while the value can change, but
 only between a given set of values (think <code>enum</code>) - using e.g. the 'customerId' as value doesn't
 make sense and will blow up your metric cardinality. Notice that if you do employ e.g. two labels, each
 having one of three values, <i>you'll effectively create 9 different meters</i>, where your measurement will
 go to one of them.
 <p/>
 <b>NOTICE: If you want to do a timing, then instead use
 <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#logTimingMeasurement-java.lang.String-java.lang.String-long-java.lang.String...-"><code>logTimingMeasurement(String, String, long, String...)</code></a></b></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>metricId</code> - constant, short, possibly dot-separated if hierarchical, id for this particular metric, e.g.
            "items" or "amount", or "db.query.orders".</dd>
<dd><code>metricDescription</code> - constant, textual description for this metric, e.g. "Number of items in customer order", "Total
            amount of customer order"</dd>
<dd><code>baseUnit</code> - the unit for this measurement, e.g. "quantity" (for a count measure), "dollar" (for an amount), or
            "bytes" (for a document size).</dd>
<dd><code>measure</code> - value of the measurement</dd>
<dd><code>labelKeyValue</code> - a String-vararg array consisting of alternate key,value pairs which will becomes labels or tags or
            entries for the metrics and log lines. <b>Read the JavaDoc above; the keys shall be "static" for a
            specific measure, while the values can change between a specific small set values.</b></dd>
</dl>
</li>
</ul>
<a name="logTimingMeasurement-java.lang.String-java.lang.String-long-java.lang.String...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>logTimingMeasurement</h4>
<pre>void&nbsp;logTimingMeasurement(java.lang.String&nbsp;metricId,
                          java.lang.String&nbsp;metricDescription,
                          long&nbsp;nanos,
                          java.lang.String...&nbsp;labelKeyValue)</pre>
<div class="block">Same as <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#logMeasurement-java.lang.String-java.lang.String-java.lang.String-double-java.lang.String...-"><code>addMeasurement(..)</code></a>, but
 specifically for timings - <b>Read that JavaDoc!</b>
 <p/>
 Note: It is illegal to use the same 'metricId' for more than one measurement for a given stage, and this also
 goes between timing measurements and <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#logMeasurement-java.lang.String-java.lang.String-java.lang.String-double-java.lang.String...-"><code>measurements</code></a>.
 <p/>
 For the metrics-plugin 'mats-intercept-micrometer' plugin, the 'baseUnit' argument is deduced to whatever is
 appropriate for the receiving metrics system, e.g. for Prometheus it is "seconds", even though you always
 record the measurement in nanoseconds using this method.
 <p/>
 For the logging-plugin 'mats-intercept-logging' plugin, the timing in the log line will be in milliseconds
 (with fractions), even though you always record the measurement in nanoseconds using this method.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>metricId</code> - constant, short, possibly dot-separated if hierarchical, id for this particular metric, e.g.
            "db.query.orders" or "calcprofit".</dd>
<dd><code>metricDescription</code> - constant, textual description for this metric, e.g. "Time taken to execute order query", "Time
            taken to calculate profit or loss".</dd>
<dd><code>nanos</code> - time taken <b>in nanoseconds</b></dd>
<dd><code>labelKeyValue</code> - a String-vararg array consisting of alternate key,value pairs which will becomes labels or tags or
            entries for the metrics and log lines. Read the JavaDoc at
            <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#logMeasurement-java.lang.String-java.lang.String-java.lang.String-double-java.lang.String...-"><code>addMeasurement(..)</code></a></dd>
</dl>
</li>
</ul>
<a name="stash--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stash</h4>
<pre>byte[]&nbsp;stash()</pre>
<div class="block">Returns a binary representation of the current Mats flow's incoming execution point, which can be
 <code>unstashed</code> again at a later time
 using the <a href="../../io/mats3/MatsInitiator.html" title="interface in io.mats3"><code>MatsInitiator</code></a>, thereby providing a simplistic "continuation" feature in Mats. You will have
 to find storage for these bytes yourself - an obvious place is the co-transactional database that the stage
 typically has available. This feature gives the ability to "pause" the current Mats flow, and later restore
 the execution from where it left off, probably with some new information that have been gathered in the
 meantime. This can typically relieve the Mats Stage Processing thread from having to wait for another
 service's execution (whose execution must then be handled by some other thread). This could be a longer
 running process, or a process whose execution time is variable, maybe residing on a Mats-external service
 structure: E.g. some REST service that sometimes lags, or sometimes is down in smaller periods. Or a service
 on a different Message Broker. Once this "Mats external" processing has finished, that thread can invoke
 <code>unstash(stashBytes,...)</code> to get the
 Mats flow going again. Notice that functionally, the unstash-operation is a kind of initiation, only that
 this type of initiation doesn't start a <i>new</i> Mats flow, rather <i>continuing an existing flow</i>.
 <p/>
 <b>Notice that this feature should not typically be used to "park" a Mats flow for days.</b> One might have a
 situation where a part of an order flow potentially needs manual handling, e.g. validating a person's
 identity if this has not been validated before. It might (should!) be tempting to employ the stash function
 then: Stash the Mats flow in a database. Make a GUI where the ID-validation can be performed by some
 employee. When the ID is either accepted or denied, you unstash the Mats flow with the result, getting a very
 nice continuous mats flow for new orders which is identical whether or not ID validation needs to be
 performed. However, if this ID-validation process can take days or weeks to execute, it will be a poor
 candidate for the stash-feature. The reason is that embedded within the execution context which you get a
 binary serialization of, there might be several serialized <i>state</i> representations of the endpoints
 laying upstream of this call flow. When you "freeze" these by invoking stash, you have immediately made a
 potential future deserialization-crash if you change the code of those upstream endpoints (which quite
 probably resides in different code bases than the one employing the stash feature), specifically changes of
 the state classes they employ: When you deploy these code changes while having multiple flows frozen in
 stashes, you will have a problem when they are later unstashed and the Mats flow returns to those endpoints
 whose state classes won't deserialize back anymore. It is worth noting that you always have these problems
 when doing deploys where the state classes of Mats endpoints change - it is just that usually, there won't be
 any, and at least not many, such flows in execution at the precise deploy moment (and also, that changing the
 state classes are in practice really not that frequent). However, by stashing over days, instead of a normal
 Mats flow that take seconds, you massively increase the time window in which such deserialization problems
 can occur. You at least have to consider this if employing the stash-functionality.
 <p/>
 <b>Note about data and metadata which should be stored along with the stash-bytes:</b> You only get a binary
 serialized incoming execution context in return from this method (which includes the incoming message,
 incoming state, the execution stack and <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getTraceProperty-java.lang.String-java.lang.Class-"><code>trace
 properties</code></a>, but not "sideloaded" <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getBytes-java.lang.String-"><code>bytes</code></a> and
 <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getString-java.lang.String-"><code>strings</code></a>). The returned byte array are utterly opaque seen from the
 Mats API side (however, depending on the serialization mechanism employed in the Mats implementation, you
 might be able to peek into them anyway - but this should at most be used for debugging/monitoring
 introspection). Therefore, any information from the incoming message, or from your state object, or anything
 else from the <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html" title="interface in io.mats3"><code>MatsEndpoint.DetachedProcessContext</code></a> which is needed to actually execute the job that should be
 performed outside of the Mats flow, <u>must be picked out manually</u> before exiting the process lambda.
 This also goes for "sideloaded" objects (<a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getBytes-java.lang.String-"><code>bytes</code></a> and
 <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getString-java.lang.String-"><code>strings</code></a>) - which will not be available inside the unstashed process
 lambda (they are not a part of the stash-bytes). Also, you should for debugging/monitoring purposes also
 store at least the Mats flow's <a href="../../io/mats3/MatsEndpoint.DetachedProcessContext.html#getTraceId--"><code>TraceId</code></a> and a timestamp along with the
 stash and data. You should probably also have some kind of monitoring / health checks for stashes that have
 become stale - i.e. stashes that have not been unstashed for a considerable time, and whose Mats flow have
 thus stopped up, and where the downstream endpoints/stages therefore will not get invoked.
 <p/>
 <b>Notes:</b>
 <ul>
 <li>Invoking <code>stash()</code> will not affect the stage processing in any way other than producing a
 serialized representation of the current incoming execution point. You can still send out messages. You could
 even reply, but then, what would be the point of stashing?</li>
 <li>Repeated invocations within the same stage will yield (effectively) the same stash, as any processing
 done inside the stage before invoking <code>stash()</code> don't affect the <i>incoming</i> execution point.</li>
 <li>You will have to exit the current process lambda yourself - meaning that this cannot be used in a
 <a href="../../io/mats3/MatsEndpoint.html#lastStage-java.lang.Class-io.mats3.MatsEndpoint.ProcessReturnLambda-"><code>lastStage</code></a>, as you cannot return from such a stage
 without actually sending a reply (<code>return null</code> replies with <code>null</code>). Instead employ a
 <a href="../../io/mats3/MatsEndpoint.html#stage-java.lang.Class-io.mats3.MatsEndpoint.ProcessLambda-"><code>normal stage</code></a>, using <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#reply-R-"><code>reply(Object)</code></a> to
 return a reply if needed.</li>
 <li>Mats won't care if you unstash() the same stash multiple times, but your downstream parts of the Mats
 flow might find this a bit strange.</li>
 </ul></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a binary representation of the current Mats flow's incoming execution point (i.e. any incoming state
         and the incoming message - along with the Mats flow stack at this point). It shall start with the 4
         ASCII letters "MATS", and then 4 more letters representing which mechanism is employed to construct
         the rest of the byte array.</dd>
</dl>
</li>
</ul>
<a name="request-java.lang.String-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>request</h4>
<pre><a href="../../io/mats3/MatsInitiator.MessageReference.html" title="interface in io.mats3">MatsInitiator.MessageReference</a>&nbsp;request(java.lang.String&nbsp;endpointId,
                                       java.lang.Object&nbsp;requestDto)</pre>
<div class="block">Sends a request message, meaning that the specified endpoint will be invoked, with the reply-to endpointId
 set to the next stage in the multi-stage endpoint.
 <p/>
 This will throw if the current process stage is a terminator, single-stage endpoint or the last endpoint of a
 multi-stage endpoint, as there then is no next stage to reply to.
 <p/>
 Note: Legal outgoing flows: Either one or several <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#request-java.lang.String-java.lang.Object-"><code>request</code></a> messages; OR a
 single <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#reply-R-"><code>reply</code></a>, <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#next-java.lang.Object-"><code>next</code></a>, <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#nextDirect-java.lang.Object-"><code>nextDirect</code></a>, or
 <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#goTo-java.lang.String-java.lang.Object-"><code>goTo</code></a> message. The reason that multiple requests are allowed is that this could
 be used in a scatter-gather scenario - where the replies come in to the next stage <i>of the same
 endpoint</i>. However, multiple replies to the <i>invoking</i> endpoint makes very little sense, which is why
 only one reply is allowed, and it cannot be combined with request or next, nor goto, as then the next stage
 could also perform a reply.
 <p/>
 Note: The current state and DTO is serialized <i>when invoking this method</i>. This means that in case of
 multiple requests, you may change the state in between each request, and the next stage will get different
 "incoming states" for each of the replies, which may be of use in a scatter-gather scenario.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>endpointId</code> - which endpoint to invoke</dd>
<dd><code>requestDto</code> - the message that should be sent to the specified endpoint.</dd>
</dl>
</li>
</ul>
<a name="reply-java.lang.Object-">
<!--   -->
</a><a name="reply-R-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reply</h4>
<pre><a href="../../io/mats3/MatsInitiator.MessageReference.html" title="interface in io.mats3">MatsInitiator.MessageReference</a>&nbsp;reply(<a href="../../io/mats3/MatsEndpoint.ProcessContext.html" title="type parameter in MatsEndpoint.ProcessContext">R</a>&nbsp;replyDto)</pre>
<div class="block">Sends a reply to the requesting service. When returning an object from a
 <a href="../../io/mats3/MatsEndpoint.html#lastStage-java.lang.Class-io.mats3.MatsEndpoint.ProcessReturnLambda-"><code>lastStage</code></a> lambda, this is the method that actually
 gets invoked.
 <p/>
 This will be ignored if there is no endpointId on the stack, i.e. if this endpoint it is semantically a
 terminator (the <code>replyTo</code> of an initiation's request), or if it is the last stage of an endpoint
 that was invoked directly (using <a href="../../io/mats3/MatsInitiator.MatsInitiate.html#send-java.lang.Object-"><code>MatsInitiate.send(msg)</code></a>).
 <p/>
 It is possible to do "early return" in a multi-stage endpoint by invoking this method in a stage that is not
 the last.
 <p/>
 Note: Legal outgoing flows: Either one or several <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#request-java.lang.String-java.lang.Object-"><code>request</code></a> messages; OR a
 single <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#reply-R-"><code>reply</code></a>, <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#next-java.lang.Object-"><code>next</code></a>, <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#nextDirect-java.lang.Object-"><code>nextDirect</code></a>, or
 <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#goTo-java.lang.String-java.lang.Object-"><code>goTo</code></a> message. The reason that multiple requests are allowed is that this could
 be used in a scatter-gather scenario - where the replies come in to the next stage <i>of the same
 endpoint</i>. However, multiple replies to the <i>invoking</i> endpoint makes very little sense, which is why
 only one reply is allowed, and it cannot be combined with request or next, nor goto, as then the next stage
 could also perform a reply.
 <p/>
 Note: The current state and DTO is serialized <i>when invoking this method</i>. Any changes to the state
 object or the DTO performed afterwards won't be present on the reply-receiving stage.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>replyDto</code> - the reply DTO to return to the invoker.</dd>
</dl>
</li>
</ul>
<a name="next-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>next</h4>
<pre><a href="../../io/mats3/MatsInitiator.MessageReference.html" title="interface in io.mats3">MatsInitiator.MessageReference</a>&nbsp;next(java.lang.Object&nbsp;nextDto)</pre>
<div class="block">Sends a message which passes the control to the next stage of a multi-stage endpoint. The functionality is
 meant for doing conditional requests, e.g.:

 <pre>
 if (something missing) {
     request another endpoint with reply coming to next stage.
 }
 else {
     pass to next stage
 }
 </pre>

 This can be of utility if an endpoint in some situations requires more information from a collaborating
 endpoint, while in other situations it does not require that information.
 <p/>
 <b>Note: You should rather use <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#nextDirect-java.lang.Object-"><code>nextDirect(Object)</code></a> if your transactional demarcation needs allows
 it!</b>
 <p/>
 Note: Legal outgoing flows: Either one or several <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#request-java.lang.String-java.lang.Object-"><code>request</code></a> messages; OR a
 single <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#reply-R-"><code>reply</code></a>, <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#next-java.lang.Object-"><code>next</code></a>, <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#nextDirect-java.lang.Object-"><code>nextDirect</code></a>, or
 <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#goTo-java.lang.String-java.lang.Object-"><code>goTo</code></a> message. The reason that multiple requests are allowed is that this could
 be used in a scatter-gather scenario - where the replies come in to the next stage <i>of the same
 endpoint</i>. However, multiple replies to the <i>invoking</i> endpoint makes very little sense, which is why
 only one reply is allowed, and it cannot be combined with request or next, nor goto, as then the next stage
 could also perform a reply.
 <p/>
 Note: The current state and DTO is serialized <i>when invoking this method</i>. Any changes to the state
 object or the DTO performed afterwards won't be present in the subsequent stage.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nextDto</code> - the object for the next stage's incoming DTO, which must match what the next stage expects. When
            using this method to skip a request, it probably often makes sense to set it to <code>null</code>,
            which the next stage then must handle correctly.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#nextDirect-java.lang.Object-"><code>nextDirect(Object)</code></a></dd>
</dl>
</li>
</ul>
<a name="nextDirect-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nextDirect</h4>
<pre>void&nbsp;nextDirect(java.lang.Object&nbsp;nextDirectDto)</pre>
<div class="block">Specialized, less resource demanding, and faster "direct" variant of <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#next-java.lang.Object-"><code>next(Object)</code></a> which executes the
 next stage of a multi-stage endpoint within the same stage processor and transactional demarcation that this
 stage is in - that is, there is no actual message sent. This ensures that you neither incur any transactional
 cost nor the overhead of serialization and sending a message on the message queue with subsequent receiving
 and deserialization.
 <p/>
 The functionality is meant for doing conditional calls, e.g.:

 <pre>
 if (something missing) {
     request another endpoint with reply coming to next stage.
 }
 else {
     directly execute the next stage
 }
 </pre>

 This can be of utility if an endpoint in some situations requires more information from a collaborating
 endpoint, while in other situations it does not require that information. A scenario nextDirect is
 particularly good for is lazy cache population where the caching of the information only incurs cost if the
 information is missing, since if the information is present in the cache, you can do a close to zero cost
 nextDirect invocation. Had you been using <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#next-java.lang.Object-"><code>ordinary next</code></a>, you would incur the cost of
 sending and receiving a message even though the information is present in the cache.
 <p/>
 Implementation details which are unspecified and whose effects or non-effects shall not be relied on:
 <ul>
 <li>It is unspecified which thread runs the next stage: The invocation may be done by the same stage
 processor thread which executes this stage, or the execution may be done by another thread. Therefore, you
 cannot expect any ThreadLocals set in this lambda to to be present in the next.</li>
 <li>It is unspecified how the next lambda is invoked: You cannot expect this to behave like a method call to
 the next lambda (i.e. the next stage has been executed when the method returns), nor can you expect the
 lambda to be executed only when the current lambda has exited (i.e. behaving like a message). Therefore,
 invocation of this method should be the very last operation in the current lambda so that this does not make
 a difference.</li>
 </ul>
 <p/>
 Some notes:
 <ul>
 <li>There is no new <i>message system message</i> created for a nextDirect, so e.g. messageIds when in the
 next stage will refer to the previous stage's incoming message.</li>
 <li>Since there is no message system message, the message broker won't see any trace of a nextDirect. This
 also means that you'll get less counts of messages on the next stage's queue.</li>
 <li>The stage processing thread for the stage doing nextDirect is busy while the next stage executes, either
 by actually executing it, or waiting for the execution, depending on the Mats implementation. If the next
 stage is slow, any queue build-up will therefore happen on the stage that performed the nextDirect. Any
 adjustment of concurrency must be done on the stage actually receiving message system messages.</li>
 <li>It is legal to do "series" of nextDirects, i.e. that one stage does a nextDirect, and then the next stage
 also does a nextDirect.</li>
 <li>Neither the state object or the DTO is serialized and deserialized, but instead passed directly to the
 next stage. This ties back to the point about unspecified way of invoking the next lambda and that the
 invocation of nextDirect should be the last operation in the current stage: It is unspecified whether a
 change to the state object or DTO <i>after</i> the invocation of nextDirect will be visible to the next
 stage. (This as opposed to all the other message sending methods, where it is specified that the objects are
 serialized upon method invocation, and any changes done afterwards will not be visible to the receiver.)</li>
 <li>If the next stage throws an exception, it will be the current stage that eventually DLQs - this might be
 confusing when researching an error.</li>
 <li>If employing MatsTrace (which the JMS impl do), it will contain no record of the nextDirect having been
 performed. For example, if the message crops up on a DLQ, any nextDirects in the flow will not be
 visible.</li>
 <li>There are implications for the Interceptors, some of which might be subtle. E.g. any preprocess and
 deserialization timings, and message sizes, will be 0. Also, read up on the <code>stageCompleted(..)</code>
 vs. <code>stageCompletedNextDirect(..)</code></li>
 </ul>
 <p/>
 Note: Legal outgoing flows: Either one or several <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#request-java.lang.String-java.lang.Object-"><code>request</code></a> messages; OR a
 single <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#reply-R-"><code>reply</code></a>, <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#next-java.lang.Object-"><code>next</code></a>, <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#nextDirect-java.lang.Object-"><code>nextDirect</code></a>, or
 <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#goTo-java.lang.String-java.lang.Object-"><code>goTo</code></a> message. The reason that multiple requests are allowed is that this could
 be used in a scatter-gather scenario - where the replies come in to the next stage <i>of the same
 endpoint</i>. However, multiple replies to the <i>invoking</i> endpoint makes very little sense, which is why
 only one reply is allowed, and it cannot be combined with request or next, nor goto, as then the next stage
 could also perform a reply.</div>
</li>
</ul>
<a name="goTo-java.lang.String-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>goTo</h4>
<pre><a href="../../io/mats3/MatsInitiator.MessageReference.html" title="interface in io.mats3">MatsInitiator.MessageReference</a>&nbsp;goTo(java.lang.String&nbsp;endpointId,
                                    java.lang.Object&nbsp;gotoDto)</pre>
<div class="block">Sends a message which passes the current call stack over to another endpoint, so that when that endpoint
 replies, it will return to the endpoint which invoked this endpoint.
 <p/>
 This would be of use in dispatcher scenarios, where you might have a case-style evaluation of the incoming
 message, and then either handle it yourself, or send the control over to some other endpoint (possibly one of
 several other endpoints) - so that when they again reply, it will be to the original caller.
 <p/>
 A specific dispatcher-like situation where this could be of use, is if you have an endpoint that for some
 specific (known) entities consumes a particularly large amount of memory. For example, you might have a
 specific set of frequent customers which when loaded takes much more memory than a normal customer. If you
 get an influx of orders for these customers at the same time, your standard endpoint with a high concurrency
 could lead to an out-of-memory situation. A solution here could be to instantiate that same endpoint code at
 two different endpointIds - the public one, and a private variant with much lower concurrency. The standard,
 public endpoint would at the initial stage evaluate if this was one of the known memory-hogging customers,
 and if so, make a context.goto(..) over to the other private endpoint with lower concurrency thereby ensuring
 that the memory usage would be contained. (The endpoint would have to evaluate if it is the public or private
 instance wrt. whether it should do the eval-then-goto: Either by looking at its endpointId (check if it is
 the private, low-concurrency variant), or by use of the <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#goTo-java.lang.String-java.lang.Object-java.lang.Object-"><code>initialState</code></a>-feature, or by modifying the DTO before goTo, or by
 <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#addString-java.lang.String-java.lang.String-"><code>sideloads</code></a>).
 <p/>
 Another use is <i>tail calls</i>, whereby one endpoint A does some preprocessing, and then invokes another
 endpoint B, but where endpoint A really just want to directly reply with the reply from endpoint B. The extra
 reply stage of endpoint A is thus totally useless and just incurs additional message passing and processing.
 You can instead just goTo endpoint B, which achieves just this outcome: When endpoint B now replies, <i>it
 will reply to the caller of endpoint A</i>.
 <p/>
 Note: Legal outgoing flows: Either one or several <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#request-java.lang.String-java.lang.Object-"><code>request</code></a> messages; OR a
 single <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#reply-R-"><code>reply</code></a>, <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#next-java.lang.Object-"><code>next</code></a>, <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#nextDirect-java.lang.Object-"><code>nextDirect</code></a>, or
 <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#goTo-java.lang.String-java.lang.Object-"><code>goTo</code></a> message. The reason that multiple requests are allowed is that this could
 be used in a scatter-gather scenario - where the replies come in to the next stage <i>of the same
 endpoint</i>. However, multiple replies to the <i>invoking</i> endpoint makes very little sense, which is why
 only one reply is allowed, and it cannot be combined with request or next, nor goto, as then the next stage
 could also perform a reply.
 <p/>
 Note: The current state and DTO is serialized <i>when invoking this method</i>. Any changes to the state
 object or the DTO performed afterwards won't be present for the targeted endpoint.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>endpointId</code> - which endpoint to go to.</dd>
<dd><code>gotoDto</code> - the message that should be sent to the specified endpoint. Will in a dispatcher scenario often be
            the incoming DTO for the current endpoint, while in a tail call situation be the requestDto for
            the target endpoint.</dd>
</dl>
</li>
</ul>
<a name="goTo-java.lang.String-java.lang.Object-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>goTo</h4>
<pre><a href="../../io/mats3/MatsInitiator.MessageReference.html" title="interface in io.mats3">MatsInitiator.MessageReference</a>&nbsp;goTo(java.lang.String&nbsp;endpointId,
                                    java.lang.Object&nbsp;gotoDto,
                                    java.lang.Object&nbsp;initialTargetSto)</pre>
<div class="block"><b>Variation of <a href="../../io/mats3/MatsEndpoint.ProcessContext.html#goTo-java.lang.String-java.lang.Object-"><code>goTo(String, Object)</code></a> method</b>, where the incoming state is sent along.
 <p/>
 <b>This only makes sense if the same code base "owns" both the current endpoint, and the endpoint to which
 this message is sent.</b></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>endpointId</code> - which endpoint to go to.</dd>
<dd><code>gotoDto</code> - the message that should be sent to the specified endpoint. Will in a dispatcher scenario often be
            the incoming DTO for the current endpoint, while in a tail call situation be the requestDto for
            the target endpoint.</dd>
<dd><code>initialTargetSto</code> - the object which the target endpoint will get as its initial stage STO (State Transfer Object).</dd>
</dl>
</li>
</ul>
<a name="initiate-io.mats3.MatsInitiator.InitiateLambda-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initiate</h4>
<pre>void&nbsp;initiate(<a href="../../io/mats3/MatsInitiator.InitiateLambda.html" title="interface in io.mats3">MatsInitiator.InitiateLambda</a>&nbsp;lambda)</pre>
<div class="block">Initiates a new message out to an endpoint. This is effectively the same as invoking
 <a href="../../io/mats3/MatsInitiator.html#initiate-io.mats3.MatsInitiator.InitiateLambda-"><code>the same method</code></a> on a <a href="../../io/mats3/MatsInitiator.html" title="interface in io.mats3"><code>MatsInitiator</code></a> gotten via
 <a href="../../io/mats3/MatsFactory.html#getOrCreateInitiator-java.lang.String-"><code>MatsFactory.getOrCreateInitiator(String)</code></a>, only that this way works within the transactional context
 of the <a href="../../io/mats3/MatsStage.html" title="interface in io.mats3"><code>MatsStage</code></a> which this method is invoked within. Also, the traceId and from-endpointId is
 predefined, but it is still recommended to set the traceId, as that will append the new string on the
 existing traceId, making log tracking (e.g. when debugging) better.
 <p/>
 <b>IMPORTANT NOTICE!!</b> The <a href="../../io/mats3/MatsInitiator.html" title="interface in io.mats3"><code>MatsInitiator</code></a> returned from <a href="../../io/mats3/MatsFactory.html#getDefaultInitiator--"><code>MatsFactory.getDefaultInitiator()</code></a> is "magic" in that when employed from within a Mats Stage's context
 (thread), it works exactly as this method: Any initiations performed participates in the Mats Stage's
 transactional demarcation. Read more at the JavaDoc of default initiator's
 <a href="../../io/mats3/MatsFactory.html#getDefaultInitiator--"><code>JavaDoc</code></a>..</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>lambda</code> - provides the <a href="../../io/mats3/MatsInitiator.MatsInitiate.html" title="interface in io.mats3"><code>MatsInitiator.MatsInitiate</code></a> instance on which to create the message to be sent.</dd>
</dl>
</li>
</ul>
<a name="doAfterCommit-java.lang.Runnable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doAfterCommit</h4>
<pre>void&nbsp;doAfterCommit(java.lang.Runnable&nbsp;runnable)</pre>
<div class="block">The Runnable will be performed after messaging and external resources (DB) have been committed. An example
 can be if the Mats-lambda inserts a row in a database that should be processed by some other component (i.e.
 a service running with some Threads), and thus wants to wake up that component telling it that new work is
 available. Problem is then that if this "wakeUp()" call is done within the lambda, the row is not technically
 there yet - as we're still within the SQL transaction demarcation. Therefore, if the process-service wakes up
 really fast and tries to find the new work, it will not see anything yet. (It might then presume that e.g.
 another node of the service-cluster took care of whatever woke it up, and go back to sleep.)
 <p/>
 Note: This is per processing; Setting it is only relevant for the current message. If you invoke the method
 more than once, only the last Runnable will be run. If you set it to <code>null</code>, you "cancel" any
 previously set Runnable.
 <p/>
 Note: If any Exception is raised from the stage lambda code after the Runnable has been set, or any Exception
 is raised by the processing or committing, the Runnable will not be run.
 <p/>
 Note: If the <code>doAfterCommit</code> Runnable throws a <code>RuntimeException</code>, it will be logged on
 ERROR level, then ignored.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>runnable</code> - the code to run right after the transaction of both external resources and messaging has been
            committed. Setting to <code>null</code> "cancels" any previously set Runnable.</dd>
</dl>
</li>
</ul>
<a name="getAttribute-java.lang.Class-java.lang.String...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAttribute</h4>
<pre>&lt;T&gt;&nbsp;java.util.Optional&lt;T&gt;&nbsp;getAttribute(java.lang.Class&lt;T&gt;&nbsp;type,
                                       java.lang.String...&nbsp;name)</pre>
<div class="block">Provides a way to get hold of (optional) attributes/objects from the Mats implementation, either specific to
 the Mats implementation in use, or configured into this instance of the Mats implementation. Is mirrored by
 the same method at <a href="../../io/mats3/MatsInitiator.MatsInitiate.html#getAttribute-java.lang.Class-java.lang.String...-"><code>MatsInitiator.MatsInitiate.getAttribute(Class, String...)</code></a>. There is also a
 ThreadLocal-accessible version at <a href="../../io/mats3/MatsFactory.ContextLocal.html#getAttribute-java.lang.Class-java.lang.String...-"><code>MatsFactory.ContextLocal.getAttribute(Class, String...)</code></a>.
 <p/>
 Mandatory: If the Mats implementation has a transactional SQL Connection, it shall be available by
 <code>'context.getAttribute(Connection.class)'</code>.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The type of the attribute.</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>type</code> - The expected type of the attribute</dd>
<dd><code>name</code> - The (optional) (hierarchical) name(s) of the attribute.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Optional of the attribute in question, the optionality pointing out that it depends on the Mats
         implementation or configuration whether it is available.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../io/mats3/MatsEndpoint.ProcessContext.html#getAttribute-java.lang.Class-java.lang.String...-"><code>getAttribute(Class, String...)</code></a>, 
<a href="../../io/mats3/MatsFactory.ContextLocal.html#getAttribute-java.lang.Class-java.lang.String...-"><code>MatsFactory.ContextLocal.getAttribute(Class, String...)</code></a></dd>
</dl>
</li>
</ul>
<a name="unwrapFully--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>unwrapFully</h4>
<pre>default&nbsp;<a href="../../io/mats3/MatsEndpoint.ProcessContext.html" title="interface in io.mats3">MatsEndpoint.ProcessContext</a>&lt;<a href="../../io/mats3/MatsEndpoint.ProcessContext.html" title="type parameter in MatsEndpoint.ProcessContext">R</a>&gt;&nbsp;unwrapFully()</pre>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>default <code>this</code> for implementations, overridden by wrappers.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../io/mats3/MatsEndpoint.MatsRefuseMessageException.html" title="class in io.mats3"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../io/mats3/MatsEndpoint.ProcessContextWrapper.html" title="class in io.mats3"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?io/mats3/MatsEndpoint.ProcessContext.html" target="_top">Frames</a></li>
<li><a href="MatsEndpoint.ProcessContext.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
